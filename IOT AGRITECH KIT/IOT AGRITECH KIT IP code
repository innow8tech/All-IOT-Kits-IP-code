#include <Wire.h>
#include <Adafruit_SHT31.h>    
#include <U8g2lib.h>   // Changed from Adafruit_SH110X to U8g2
#include <Arduino.h>
#include <WiFi.h>              
#include <AsyncTCP.h>          
#include <ESPAsyncWebServer.h>
#include <FastLED.h>           // Add FastLED for WS2812B control

/****************** I2C Addresses *****************/
#define RAINFALL_SENSOR_ADDRESS 0x5B
#define LDR_SENSOR_ADDRESS      0x08
#define OBSTACLE_SENSOR_ADDRESS 0x09
#define FAN_ADDRESS             0x5C
#define PUMP_ADDRESS            0x5D
#define SOIL_MOISTURE_ADDRESS   0x11  // Updated address to match reference
#define COMMAND_REQUEST_DATA    2

#define OLED_I2C_ADDRESS 0x3C
#define RAINFALL_COMMAND 0x01

// U8G2 Constructor - SH1106 128x64 I2C
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);
Adafruit_SHT31   sht31   = Adafruit_SHT31(); 

bool fanState = false;
bool pumpState = false; 

#define BTN_UP     18
#define BTN_DOWN   16
#define BTN_LEFT   17
#define BTN_RIGHT  4
#define BTN_CENTER 5

int currentScreen     = 0; 
const int totalScreens = 8; // Reduced from 10

#define TOUCH_PIN1  32
#define TOUCH_PIN2  33
#define TOUCH_PIN3  14
#define TOUCH_PIN4  12
#define BUZZER_PIN  19

int threshold = 30;  
int touch1, touch2, touch3, touch4;

/****************** IoT Mode **********************/
#define AP_SSID       "AGRITECH"
#define AP_PASSWORD   "12345678"
bool iotModeActive = false;

AsyncWebServer server(80);

/****************** WS2812B LED Configuration *****************/
#define LED_PIN     27
#define NUM_LEDS    12
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB

CRGB leds[NUM_LEDS];

// LED animation variables
uint8_t gHue = 0; // rotating "base color" used by many of the patterns
unsigned long lastLEDUpdate = 0;
const unsigned long LED_UPDATE_INTERVAL = 50; // Update every 50ms for smooth animation

/****************** Function Prototypes ***********/
void configureBuzzer();
void playTone(int frequency);
void stopTone();
void handleNavigation();
void updateDisplay();       
void updateDetailView();   
void updateFanControlView();
void updatePumpControlView();
void updateLDRView();
void updateObstacleView();
void updateSoilMoistureView();
void updateMusicModeView();
void updateIoTModeScreen();
void showProfessionalBootScreen();
void drawProgressBar(int x, int y, int width, int height, int percentage);
void drawStatusIndicator(int x, int y, bool state);
void drawIcon(int x, int y, const char* icon);
String getRainfallStatus();
String readLDRStatus();
String readObstacleStatus();
String readSoilMoistureStatus();
uint8_t readLDRValue();
uint8_t readSoilMoistureValue();
void controlFan(bool state);
void controlPump(bool state);
void setupWiFiAP();
void stopWiFiAP();
String buildJSONData();
void setupLEDs();
void updateLEDs();
void rainbowProgressBar(uint8_t progress);
void rainbowCycle();
uint8_t calculateLEDProgress(uint8_t ldrValue);

/*************************************************
 *        Professional Dashboard HTML
 *************************************************/
const char dashboard_html[] PROGMEM = R"====(
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AGRITECH Monitoring Dashboard</title>
    <style>
        :root {
            --primary-color: #27AE60;
            --secondary-color: #2ECC71;
            --accent-color: #F39C12;
            --danger-color: #E74C3C;
            --success-color: #27AE60;
            --warning-color: #FF6B35;
            --dark-color: #2C3E50;
            --light-color: #E8F5E8;
            --text-color: #2C3E50;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #FFF3CD, #FFF8DC, #FFFACD);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(39, 174, 96, 0.3);
        }

        .header h1 {
            font-size: clamp(1.8rem, 4vw, 3rem);
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header .subtitle {
            font-size: clamp(1rem, 2vw, 1.2rem);
            opacity: 0.95;
        }

        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 15px;
        }

        .system-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .status-card {
            background: linear-gradient(145deg, white, var(--light-color));
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.15);
            border: 2px solid var(--accent-color);
            transition: transform 0.3s ease;
        }

        .status-card:hover {
            transform: translateY(-3px);
        }

        .status-value {
            font-size: clamp(1.2rem, 3vw, 1.6rem);
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .status-label {
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            color: var(--dark-color);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .card {
            background: linear-gradient(145deg, white, var(--light-color));
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 6px 25px rgba(39, 174, 96, 0.15);
            border: 2px solid var(--accent-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(39, 174, 96, 0.2);
        }

        .card-title {
            font-size: clamp(1.2rem, 3vw, 1.4rem);
            font-weight: 700;
            margin-bottom: 20px;
            color: var(--primary-color);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
        }

        .control-section {
            text-align: center;
        }

        .control-btn {
            background: linear-gradient(145deg, var(--primary-color), var(--secondary-color));
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: clamp(1rem, 2.5vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }

        .control-btn.active {
            background: linear-gradient(145deg, var(--success-color), #229954);
        }

        .sensor-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .sensor-item {
            background: linear-gradient(145deg, #FFFEF7, #FFF8DC);
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid var(--accent-color);
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(39, 174, 96, 0.1);
        }

        .sensor-item:hover {
            transform: scale(1.02);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.2);
        }

        .sensor-label {
            font-size: clamp(0.8rem, 2vw, 0.9rem);
            font-weight: 600;
            color: var(--dark-color);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .sensor-value {
            font-size: clamp(1.4rem, 4vw, 1.8rem);
            font-weight: 700;
            color: var(--primary-color);
            margin: 10px 0;
        }

        .gauge-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 10px auto;
        }

        .gauge-circle {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                var(--danger-color) 0%,
                var(--warning-color) 25%,
                var(--accent-color) 50%,
                var(--success-color) 75%,
                var(--primary-color) 100%
            );
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .gauge-circle::before {
            content: '';
            position: absolute;
            width: 90px;
            height: 90px;
            background: white;
            border-radius: 50%;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1);
        }

        .gauge-text {
            position: absolute;
            font-size: clamp(1rem, 3vw, 1.2rem);
            font-weight: 700;
            color: var(--primary-color);
            z-index: 10;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-on { 
            background-color: var(--success-color);
            animation: blink 1s infinite;
        }
        .status-off { 
            background-color: #95A5A6; 
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.6; }
        }

        .alert {
            background: linear-gradient(145deg, var(--danger-color), #C0392B) !important;
            color: white !important;
            animation: alertPulse 1s infinite;
        }

        .safe {
            background: linear-gradient(145deg, var(--success-color), #229954) !important;
            color: white !important;
        }

        .warning {
            background: linear-gradient(145deg, var(--warning-color), #E74C3C) !important;
            color: white !important;
        }

        @keyframes alertPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .footer {
            background: linear-gradient(135deg, var(--dark-color), #34495E);
            color: white;
            text-align: center;
            padding: 20px;
            margin-top: 30px;
        }

        .footer h3 {
            font-size: clamp(1.2rem, 3vw, 1.4rem);
            margin-bottom: 5px;
        }

        .footer p {
            font-size: clamp(0.9rem, 2vw, 1rem);
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 0 10px;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .sensor-grid {
                grid-template-columns: 1fr;
            }
            
            .system-status {
                grid-template-columns: 1fr;
            }
            
            .gauge-container {
                width: 100px;
                height: 100px;
            }
            
            .gauge-circle::before {
                width: 80px;
                height: 80px;
            }
        }

        @media (max-width: 480px) {
            .system-status {
                grid-template-columns: 1fr;
            }
            
            .sensor-grid {
                grid-template-columns: 1fr;
            }
            
            .header {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸŒ± AGRITECH Dashboard</h1>
        <div class="subtitle">Agricultural Monitoring & Control System</div>
    </div>
    
    <div class="container">
        <div class="system-status">
            <div class="status-card">
                <div class="status-value" id="systemTime">--:--:--</div>
                <div class="status-label">System Time</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="connectionStatus">Connecting...</div>
                <div class="status-label">Connection</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="lastUpdate">Never</div>
                <div class="status-label">Last Update</div>
            </div>
            <div class="status-card">
                <div class="status-value" id="deviceCount">0</div>
                <div class="status-label">Active Devices</div>
            </div>
        </div>

        <div class="dashboard-grid">
            <div class="card">
                <h2 class="card-title">System Controls</h2>
                <div class="control-section">
                    <button class="control-btn" id="fanBtn" onclick="toggleFan()">
                        <span class="status-indicator status-off"></span>
                        Fan: OFF
                    </button>
                    <br><br>
                    <button class="control-btn" id="pumpBtn" onclick="togglePump()">
                        <span class="status-indicator status-off"></span>
                        Pump: OFF
                    </button>
                </div>
            </div>
            
            <div class="card">
                <h2 class="card-title">Environmental Sensors</h2>
                <div class="sensor-grid">
                    <div class="sensor-item">
                        <div class="sensor-label">Temperature</div>
                        <div class="gauge-container">
                            <div class="gauge-circle">
                                <div class="gauge-text" id="tempGauge">--Â°C</div>
                            </div>
                        </div>
                    </div>
                    <div class="sensor-item">
                        <div class="sensor-label">Humidity</div>
                        <div class="gauge-container">
                            <div class="gauge-circle">
                                <div class="gauge-text" id="humGauge">--%</div>
                            </div>
                        </div>
                    </div>
                    <div class="sensor-item">
                        <div class="sensor-label">Rainfall</div>
                        <div class="sensor-value" id="rainValue">--</div>
                    </div>
                    <div class="sensor-item">
                        <div class="sensor-label">Light Level</div>
                        <div class="gauge-container">
                            <div class="gauge-circle">
                                <div class="gauge-text" id="ldrGauge">--</div>
                            </div>
                        </div>
                        <div style="font-size: 0.9em; margin-top: 5px;" id="ldrStatus">--</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2 class="card-title">Agriculture Sensors</h2>
                <div class="sensor-grid">
                    <div class="sensor-item" id="soilCard">
                        <div class="sensor-label">Soil Moisture</div>
                        <div class="sensor-value" id="soilValue">--</div>
                        <div style="font-size: 0.9em; margin-top: 5px;" id="soilStatus">--</div>
                    </div>
                    <div class="sensor-item" id="obstacleCard">
                        <div class="sensor-label">Obstacle Detection</div>
                        <div class="sensor-value" id="obstacleValue">--</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <h3>AGRITECH Agricultural Monitoring System</h3>
        <p>Smart Farming Solutions &copy; 2024</p>
    </div>

    <script>
        let isConnected = false;
        let updateCount = 0;

        function updateTime() {
            const now = new Date();
            document.getElementById('systemTime').textContent = now.toLocaleTimeString();
        }

        function toggleFan() {
            fetch('/toggleFan')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    const btn = document.getElementById("fanBtn");
                    if (data.fan == 1 || data.fan === true) {
                        btn.innerHTML = '<span class="status-indicator status-on"></span>Fan: ON';
                        btn.classList.add('active');
                    } else {
                        btn.innerHTML = '<span class="status-indicator status-off"></span>Fan: OFF';
                        btn.classList.remove('active');
                    }
                    console.log('Fan toggled:', data.fan);
                })
                .catch(error => {
                    console.error('Error toggling fan:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                    isConnected = false;
                });
        }

        function togglePump() {
            fetch('/togglePump')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    const btn = document.getElementById("pumpBtn");
                    if (data.pump == 1 || data.pump === true) {
                        btn.innerHTML = '<span class="status-indicator status-on"></span>Pump: ON';
                        btn.classList.add('active');
                    } else {
                        btn.innerHTML = '<span class="status-indicator status-off"></span>Pump: OFF';
                        btn.classList.remove('active');
                    }
                    console.log('Pump toggled:', data.pump);
                })
                .catch(error => {
                    console.error('Error toggling pump:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                    isConnected = false;
                });
        }

        function updateSensorCard(id, status) {
            const card = document.getElementById(id);
            if (!card) return;
            
            card.classList.remove('alert', 'safe', 'warning');
            
            if (status === "Detected" || status === "Dry" || status === "Dark") {
                card.classList.add('alert');
            } else if (status === "Clear" || status === "Wet" || status === "Bright") {
                card.classList.add('safe');
            } else if (status === "Error") {
                card.classList.add('warning');
            }
        }

        function updateData() {
            fetch('/data')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(data => {
                    console.log('Received data:', data);
                    updateCount++;
                    
                    // Update environmental sensors
                    const temp = data.temperature || 0;
                    const hum = data.humidity || 0;
                    const ldrVal = data.ldrValue || 0;
                    
                    document.getElementById("tempGauge").textContent = temp + "Â°C";
                    document.getElementById("humGauge").textContent = hum + "%";
                    document.getElementById("rainValue").textContent = data.rainfall || "--";
                    document.getElementById("ldrGauge").textContent = ldrVal;
                    document.getElementById("ldrStatus").textContent = data.ldrStatus || "--";
                    
                    // Update agriculture sensors
                    document.getElementById("soilValue").textContent = data.soilMoisture || "--";
                    document.getElementById("soilStatus").textContent = data.soilStatus || "--";
                    document.getElementById("obstacleValue").textContent = data.obstacle || "--";
                    
                    // Update control buttons
                    const fanBtn = document.getElementById("fanBtn");
                    if (data.fan == 1 || data.fan === true || data.fan === "true") {
                        fanBtn.innerHTML = '<span class="status-indicator status-on"></span>Fan: ON';
                        fanBtn.classList.add('active');
                    } else {
                        fanBtn.innerHTML = '<span class="status-indicator status-off"></span>Fan: OFF';
                        fanBtn.classList.remove('active');
                    }
                    
                    const pumpBtn = document.getElementById("pumpBtn");
                    if (data.pump == 1 || data.pump === true || data.pump === "true") {
                        pumpBtn.innerHTML = '<span class="status-indicator status-on"></span>Pump: ON';
                        pumpBtn.classList.add('active');
                    } else {
                        pumpBtn.innerHTML = '<span class="status-indicator status-off"></span>Pump: OFF';
                        pumpBtn.classList.remove('active');
                    }
                    
                    // Update sensor card styles
                    updateSensorCard("soilCard", data.soilStatus);
                    updateSensorCard("obstacleCard", data.obstacle);
                    
                    // Update connection status
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
                    document.getElementById('deviceCount').textContent = updateCount;
                    isConnected = true;
                })
                .catch(error => {
                    console.error('Error fetching data:', error);
                    document.getElementById('connectionStatus').textContent = 'Error';
                    isConnected = false;
                });
        }

        // Initialize
        updateTime();
        
        // Initial data fetch
        setTimeout(updateData, 1000);
        
        // Auto-update intervals
        setInterval(updateTime, 1000);
        setInterval(updateData, 3000); // Every 3 seconds for more reliable updates
    </script>
</body>
</html>
)====";

/*************************************************
 *   JSON Data Builder - Updated for AGRITECH sensors
 *************************************************/
String buildJSONData() {
  String rainfallStatus = getRainfallStatus();
  float  temperature    = sht31.readTemperature();
  float  humidity       = sht31.readHumidity();
  String ldrStatus      = readLDRStatus();
  uint8_t ldrValue      = readLDRValue();
  String soilStatus     = readSoilMoistureStatus();
  uint8_t soilValue     = readSoilMoistureValue();
  String obstacleStatus = readObstacleStatus();

  // Handle temperature - ensure valid range
  int tempDisplay = 0;
  if (!isnan(temperature)) {
    tempDisplay = constrain((int)temperature, -50, 100);
  }

  // Handle humidity - ensure valid range
  int humDisplay = 0;
  if (!isnan(humidity)) {
    humDisplay = constrain((int)humidity, 0, 100);
  }

  String json = "{";
  json += "\"temperature\":" + String(tempDisplay) + ",";
  json += "\"humidity\":"    + String(humDisplay)  + ",";
  json += "\"rainfall\":\""  + rainfallStatus   + "\",";
  json += "\"ldrStatus\":\""  + ldrStatus       + "\",";
  json += "\"ldrValue\":"    + String(ldrValue) + ",";
  json += "\"soilMoisture\":" + String(soilValue) + ",";
  json += "\"soilStatus\":\"" + soilStatus      + "\",";
  json += "\"obstacle\":\""  + obstacleStatus   + "\",";
  json += "\"fan\":"         + String(fanState ? 1 : 0) + ",";
  json += "\"pump\":"        + String(pumpState ? 1 : 0);
  json += "}";

  Serial.println("JSON Output: " + json);
  return json;
}

/*************************************************
 *        Setup & Main Loop
 *************************************************/
void setup() {
  Serial.begin(115200);
  Wire.begin(21, 22);
  Wire.setClock(400000);

  // Initialize LEDs
  setupLEDs();

  // Initialize U8g2
  u8g2.begin();
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.sendBuffer();

  showProfessionalBootScreen();
  
  if (!sht31.begin(0x45)) {
    Serial.println("SHT31 not found. Check wiring!");
  } else {
    Serial.println("SHT31 Sensor initialized successfully.");
  }

  // Test I2C sensors connectivity
  Serial.println("Testing I2C Sensors...");
  Serial.print("LDR Sensor (0x");
  Serial.print(LDR_SENSOR_ADDRESS, HEX);
  Serial.print("): ");
  Wire.beginTransmission(LDR_SENSOR_ADDRESS);
  if (Wire.endTransmission() == 0) {
    Serial.println("Connected");
  } else {
    Serial.println("Not Found");
  }
  
  Serial.print("Soil Moisture Sensor (0x");
  Serial.print(SOIL_MOISTURE_ADDRESS, HEX);
  Serial.print("): ");
  Wire.beginTransmission(SOIL_MOISTURE_ADDRESS);
  if (Wire.endTransmission() == 0) {
    Serial.println("Connected");
  } else {
    Serial.println("Not Found");
  }

  pinMode(BTN_UP,     INPUT_PULLUP);
  pinMode(BTN_DOWN,   INPUT_PULLUP);
  pinMode(BTN_LEFT,   INPUT_PULLUP);
  pinMode(BTN_RIGHT,  INPUT_PULLUP);
  pinMode(BTN_CENTER, INPUT_PULLUP);

  touchAttachInterrupt(TOUCH_PIN1, NULL, threshold);
  touchAttachInterrupt(TOUCH_PIN2, NULL, threshold);
  touchAttachInterrupt(TOUCH_PIN3, NULL, threshold);
  touchAttachInterrupt(TOUCH_PIN4, NULL, threshold);

  configureBuzzer();
  updateDisplay();

  setupWiFiAP();

  server.on("/", HTTP_GET, [](AsyncWebServerRequest *request){
    request->send_P(200, "text/html", dashboard_html);
  });

  server.on("/data", HTTP_GET, [](AsyncWebServerRequest *request){
    String json = buildJSONData();
    request->send(200, "application/json", json);
  });

  server.on("/toggleFan", HTTP_GET, [](AsyncWebServerRequest *request){
    fanState = !fanState;
    controlFan(fanState);
    String resp = "{\"fan\":" + String(fanState ? 1 : 0) + "}";
    request->send(200, "application/json", resp);
  });

  server.on("/togglePump", HTTP_GET, [](AsyncWebServerRequest *request){
    pumpState = !pumpState;
    controlPump(pumpState);
    String resp = "{\"pump\":" + String(pumpState ? 1 : 0) + "}";
    request->send(200, "application/json", resp);
  });

  server.begin();
  Serial.println("AGRITECH Agricultural Monitoring System Ready.");
}

void loop() {
  handleNavigation();
  
  // Update LEDs based on LDR value
  updateLEDs();

  switch (currentScreen) {
    case 0:  
      updateDisplay();
      break;
    case 1: case 2: case 3:
      updateDetailView();
      break;
    case 4:
      updateFanControlView();
      break;
    case 5:
      updatePumpControlView();
      break;
    case 6:
      updateLDRView();
      break;
    case 7:
      updateObstacleView();
      break;
    case 8:
      updateSoilMoistureView();
      break;
    case 9:
      updateMusicModeView();
      break;
    case 10:
      updateIoTModeScreen();
      break;
    default:
      currentScreen = 0;
      updateDisplay();
      break;
  }
}

/*************************************************
 *        Navigation Handler
 *************************************************/
void handleNavigation() {
  if (currentScreen != 9 && currentScreen != 10) {
    if (digitalRead(BTN_UP) == LOW) {
      currentScreen = (currentScreen - 1 + 9) % 9;
      delay(200); 
    }
    if (digitalRead(BTN_DOWN) == LOW) {
      currentScreen = (currentScreen + 1) % 9;
      delay(200); 
    }
  }

  // Music Mode - LEFT to enter, RIGHT to exit
  if (currentScreen == 0 && digitalRead(BTN_LEFT) == LOW) {
    currentScreen = 9;
    delay(200);
  }
  if (currentScreen == 9 && digitalRead(BTN_RIGHT) == LOW) {
    currentScreen = 0;
    delay(200);
  }

  // IoT Mode - RIGHT to enter, LEFT to exit  
  if (currentScreen == 0 && digitalRead(BTN_RIGHT) == LOW && !iotModeActive) {
    iotModeActive = true;
    currentScreen = 10;
    delay(200);
  }
  if (currentScreen == 10 && digitalRead(BTN_LEFT) == LOW) {
    stopWiFiAP();
    iotModeActive = false;
    currentScreen = 0;
    delay(200);
  }

  if (digitalRead(BTN_CENTER) == LOW) {
    if (currentScreen == 4) { // Fan control screen
      fanState = !fanState;
      controlFan(fanState);
      delay(300);
    } else if (currentScreen == 5) { // Pump control screen
      pumpState = !pumpState;
      controlPump(pumpState);
      delay(300);
    }
  }
}

/*************************************************
 *        Helper Functions
 *************************************************/
void drawIcon(int x, int y, const char* icon) {
  u8g2.setFont(u8g2_font_unifont_t_symbols);
  u8g2.drawStr(x, y, icon);
}

void drawProgressBar(int x, int y, int width, int height, int percentage) {
  u8g2.drawFrame(x, y, width, height);
  int fillWidth = map(percentage, 0, 100, 0, width - 2);
  if (fillWidth > 0) {
    u8g2.drawBox(x + 1, y + 1, fillWidth, height - 2);
  }
}

void drawStatusIndicator(int x, int y, bool state) {
  if (state) {
    u8g2.drawDisc(x, y, 3);
  } else {
    u8g2.drawCircle(x, y, 3);
  }
}

/*************************************************
 *        Enhanced Professional Boot Screen
 *************************************************/
void showProfessionalBootScreen() {
  // Phase 1: Animated Logo with better effects
  for (int frame = 0; frame < 25; frame++) {
    u8g2.clearBuffer();
    
    // Animated border with pulsing effect
    if (frame > 3) {
      int borderSize = 2 + (frame % 4);
      u8g2.drawRFrame(10, 8, 108, 48, 5);
      if (frame > 8) {
        u8g2.drawRFrame(12, 10, 104, 44, 3);
      }
    }
    
    // Company name with sliding animation
    if (frame > 6) {
      u8g2.setFont(u8g2_font_ncenB14_tr);
      int textX = max(25, 150 - frame * 8);
      u8g2.drawStr(textX, 32, "AGRITECH");
    }
    
    // Version info with fade-in effect
    if (frame > 15) {
      u8g2.setFont(u8g2_font_6x10_tr);
      u8g2.drawStr(32, 45, "SMART FARM");
    }
    
    // Loading dots animation
    if (frame > 10) {
      for (int i = 0; i < 3; i++) {
        if ((frame + i * 3) % 9 < 6) {
          u8g2.drawDisc(45 + i * 10, 50, 1);
        }
      }
    }
    
    u8g2.sendBuffer();
    delay(80);
  }
  
  // Phase 2: Enhanced Loading sequence
  const char* loadSteps[] = {
    "Initializing Core...",
    "Loading Sensors...", 
    "Configuring Farm...",
    "Starting Services...",
    "System Ready!"
  };
  
  for (int step = 0; step < 5; step++) {
    u8g2.clearBuffer();
    
    // Centered header
    u8g2.setFont(u8g2_font_ncenB10_tr);
    u8g2.drawStr(30, 15, "AGRITECH");
    
    // Loading text - centered
    u8g2.setFont(u8g2_font_6x10_tr);
    int textWidth = strlen(loadSteps[step]) * 6;
    int textX = (128 - textWidth) / 2;
    u8g2.drawStr(textX, 32, loadSteps[step]);
    
    // Enhanced progress bar with animation
    int progress = ((step + 1) * 100) / 5;
    u8g2.drawRFrame(14, 42, 100, 10, 2);
    u8g2.drawBox(16, 44, (progress * 96) / 100, 6);
    
    // Animated progress indicator
    int indicatorX = 16 + (progress * 96) / 100;
    if (step < 4) {
      u8g2.drawDisc(indicatorX, 47, 2);
    }
    
    // Centered percentage
    u8g2.setCursor(58, 60);
    u8g2.print(progress);
    u8g2.print("%");
    
    u8g2.sendBuffer();
    delay(700);
  }
  
  delay(500);
}

/*************************************************
 *        Improved Main Display
 *************************************************/
void updateDisplay() {
  String rainfallStatus = getRainfallStatus();
  float  temperature    = sht31.readTemperature();
  float  humidity       = sht31.readHumidity();
  String ldrStatus      = readLDRStatus();
  String soilStatus     = readSoilMoistureStatus();
  uint8_t ldrValue      = readLDRValue();

  // Buzzer alerts for agricultural conditions
  static unsigned long lastBuzzerTime = 0;
  unsigned long currentTime = millis();
  
  if (currentTime - lastBuzzerTime > 2000) { // Check every 2 seconds
    if (rainfallStatus == "Wet") {
      // Rain detected - 2 short beeps
      tone(BUZZER_PIN, 1000, 200);
      delay(250);
      tone(BUZZER_PIN, 1000, 200);
      lastBuzzerTime = currentTime;
    }
    // Removed soilStatus == "Dry" beep
  }

  u8g2.clearBuffer();

  // Environmental sensors grid
  // Temperature - Top Left
  u8g2.drawRFrame(3, 2, 58, 19, 2);
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(6, 9, "TEMP");
  u8g2.setFont(u8g2_font_6x10_tr);
  String tempStr = isnan(temperature) ? "--.-C" : String(temperature, 1) + "C";
  int tempX = 6 + (52 - tempStr.length() * 6) / 2;
  u8g2.drawStr(tempX, 18, tempStr.c_str());
  
  // Humidity - Top Right
  u8g2.drawRFrame(67, 2, 58, 19, 2);
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(70, 9, "HUM");
  u8g2.setFont(u8g2_font_6x10_tr);
  String humStr = isnan(humidity) ? "--%%" : String((int)humidity) + "%";
  int humX = 70 + (52 - humStr.length() * 6) / 2;
  u8g2.drawStr(humX, 18, humStr.c_str());
  
  // Soil Moisture - Middle Left
  u8g2.drawRFrame(3, 24, 58, 19, 2);
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(6, 31, "SOIL");
  u8g2.setFont(u8g2_font_6x10_tr);
  int soilX = 6 + (52 - soilStatus.length() * 6) / 2;
  u8g2.drawStr(soilX, 40, soilStatus.c_str());
  
  // Light Level with LED indicator - Middle Right
  u8g2.drawRFrame(67, 24, 58, 19, 2);
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(70, 31, "LIGHT");
  u8g2.setFont(u8g2_font_6x10_tr);
  // Show both status and LED count
  String ldrText = ldrStatus + " " + String(calculateLEDProgress(ldrValue));
  int ldrX = 70 + (52 - ldrText.length() * 6) / 2;
  u8g2.drawStr(ldrX, 40, ldrText.c_str());
  
  // Navigation bar with better visibility
  u8g2.drawHLine(0, 47, 128);
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(5, 56, "UP:DET");
  u8g2.drawStr(45, 56, "L:MUS");
  u8g2.drawStr(90, 56, "R:IoT");
  
  u8g2.sendBuffer();
}

/*************************************************
 *        Enhanced Detail Views
 *************************************************/
void updateDetailView() {
  // Add buzzer alerts for detail views
  static unsigned long lastDetailBuzzerTime = 0;
  unsigned long currentTime = millis();
  
  u8g2.clearBuffer();

  switch (currentScreen) {
    case 1: { // Rainfall Detail
      String rainfallStatus = getRainfallStatus();
      
      // Buzzer alert for rain in detail view
      if (currentTime - lastDetailBuzzerTime > 3000 && rainfallStatus == "Wet") {
        tone(BUZZER_PIN, 1000, 200);
        delay(250);
        tone(BUZZER_PIN, 1000, 200);
        lastDetailBuzzerTime = currentTime;
      }
      
      // Centered header
      u8g2.drawBox(0, 0, 128, 12);
      u8g2.setColorIndex(0);
      u8g2.setFont(u8g2_font_7x13B_tr);
      u8g2.drawStr(35, 9, "RAINFALL");
      u8g2.setColorIndex(1);
      
      // Main display area - centered
      u8g2.drawRFrame(15, 16, 98, 30, 4);
      
      // Status text - centered
      u8g2.setFont(u8g2_font_ncenB10_tr);
      int statusX = 19 + (90 - rainfallStatus.length() * 10) / 2;
      u8g2.drawStr(statusX, 32, rainfallStatus.c_str());
      
      // Enhanced animated rain drops
      if (rainfallStatus == "Wet") {
        for (int i = 0; i < 6; i++) {
          int dropY = 18 + (millis() / 150 + i * 4) % 12;
          int dropX = 80 + i * 6;
          u8g2.drawPixel(dropX, dropY);
          u8g2.drawPixel(dropX, dropY + 1);
          u8g2.drawPixel(dropX, dropY + 2);
        }
      }
      
      // Centered condition text
      u8g2.setFont(u8g2_font_6x10_tr);
      String conditionText = "Condition: " + String(rainfallStatus == "Wet" ? "RAINING" : "DRY");
      int condX = (128 - conditionText.length() * 6) / 2;
      u8g2.drawStr(condX, 55, conditionText.c_str());
      
      break;
    }
    
    case 2: { // Temperature Detail with thermometer animation
      float temperature = sht31.readTemperature();
      
      // Centered header
      u8g2.drawBox(0, 0, 128, 12);
      u8g2.setColorIndex(0);
      u8g2.setFont(u8g2_font_7x13B_tr);
      u8g2.drawStr(20, 9, "TEMPERATURE");
      u8g2.setColorIndex(1);
      
      // Main display - centered
      u8g2.drawRFrame(20, 16, 88, 30, 4);
      
      // Temperature value - properly centered
      if (!isnan(temperature)) {
        u8g2.setFont(u8g2_font_ncenB14_tr);
        String tempText = String(temperature, 1) + "C";
        // Calculate proper center position
        int textWidth = tempText.length() * 10; // Approximate width for this font
        int tempX = 20 + (88 - textWidth) / 2;
        u8g2.drawStr(tempX, 35, tempText.c_str());
        
        // Animated thermometer bar
        int tempLevel = map(constrain(temperature, 0, 50), 0, 50, 0, 20);
        u8g2.drawFrame(25, 20, 4, 22);
        u8g2.drawBox(26, 41 - tempLevel, 2, tempLevel);
        u8g2.drawDisc(27, 42, 2);
      } else {
        u8g2.setFont(u8g2_font_7x13B_tr);
        u8g2.drawStr(50, 32, "ERROR");
      }
      
      // Status classification - centered
      u8g2.setFont(u8g2_font_6x10_tr);
      String status = "Status: ";
      if (temperature < 15) status += "COLD";
      else if (temperature < 25) status += "NORMAL";
      else if (temperature < 35) status += "WARM";
      else status += "HOT";
      
      int statusX = (128 - status.length() * 6) / 2;
      u8g2.drawStr(statusX, 55, status.c_str());
      
      break;
    }
    
    case 3: { // Humidity Detail with animated water drops
      float humidity = sht31.readHumidity();
      
      // Centered header
      u8g2.drawBox(0, 0, 128, 12);
      u8g2.setColorIndex(0);
      u8g2.setFont(u8g2_font_7x13B_tr);
      u8g2.drawStr(35, 9, "HUMIDITY");
      u8g2.setColorIndex(1);
      
      // Main display - centered
      u8g2.drawRFrame(20, 16, 88, 30, 4);
      
      // Humidity value - centered
      if (!isnan(humidity)) {
        u8g2.setFont(u8g2_font_ncenB14_tr);
        String humText = String((int)humidity) + "%";
        int humX = 24 + (80 - humText.length() * 14) / 2;
        u8g2.drawStr(humX, 35, humText.c_str());
        
        // Animated water drops based on humidity
        if (humidity > 60) {
          for (int i = 0; i < 3; i++) {
            int dropY = 20 + (millis() / 200 + i * 3) % 8;
            u8g2.drawCircle(85 + i * 8, dropY, 1);
          }
        }
      } else {
        u8g2.setFont(u8g2_font_7x13B_tr);
        u8g2.drawStr(50, 32, "ERROR");
      }
      
      // Enhanced humidity bar - centered
      if (!isnan(humidity)) {
        u8g2.drawFrame(24, 50, 80, 6);
        int barWidth = map(humidity, 0, 100, 0, 78);
        u8g2.drawBox(25, 51, barWidth, 4);
      }
      
      // Status - centered
      u8g2.setFont(u8g2_font_6x10_tr);
      String humStatus = humidity < 30 ? "[DRY]" : humidity < 60 ? "[NORMAL]" : "[HUMID]";
      int humStatusX = (128 - humStatus.length() * 6) / 2;
      u8g2.drawStr(humStatusX, 62, humStatus.c_str());
      
      break;
    }
  }

  // Centered navigation footer
  u8g2.setFont(u8g2_font_micro_tr);
  u8g2.drawStr(40, 63, "UP/DOWN:NAV");

  u8g2.sendBuffer();
}

/*************************************************
 *        New Agricultural Sensor Views
 *************************************************/
void updateFanControlView() {
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(25, 9, "FAN CONTROL");
  u8g2.setColorIndex(1);
  
  // Main control area - centered
  u8g2.drawRFrame(20, 16, 88, 32, 4);
  
  // Status display - centered
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(45, 25, "Status:");
  u8g2.setFont(u8g2_font_ncenB14_tr);
  String statusText = fanState ? "ON" : "OFF";
  int statusX = 24 + (80 - statusText.length() * 14) / 2;
  u8g2.drawStr(statusX, 40, statusText.c_str());
  
  // Enhanced visual indicator with animation
  if (fanState) {
    if ((millis() / 300) % 2) {
      u8g2.drawDisc(90, 32, 4);
    }
    u8g2.drawCircle(90, 32, 6);
    u8g2.drawCircle(90, 32, 8);
  } else {
    u8g2.drawCircle(90, 32, 4);
  }
  
  // Centered control instruction
  u8g2.drawBox(0, 52, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_6x10_tr);
  String instruction = "PRESS CENTER TO TOGGLE";
  int instrX = (128 - instruction.length() * 6) / 2;
  u8g2.drawStr(instrX, 60, instruction.c_str());
  u8g2.setColorIndex(1);
  
  u8g2.sendBuffer();
}

void updatePumpControlView() {
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(20, 9, "PUMP CONTROL");
  u8g2.setColorIndex(1);
  
  // Main control area - centered
  u8g2.drawRFrame(20, 16, 88, 32, 4);
  
  // Status display - centered
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(45, 25, "Status:");
  u8g2.setFont(u8g2_font_ncenB14_tr);
  String statusText = pumpState ? "ON" : "OFF";
  int statusX = 24 + (80 - statusText.length() * 14) / 2;
  u8g2.drawStr(statusX, 40, statusText.c_str());
  
  // Enhanced visual indicator with animation
  if (pumpState) {
    if ((millis() / 300) % 2) {
      u8g2.drawDisc(90, 32, 4);
    }
    u8g2.drawCircle(90, 32, 6);
    u8g2.drawCircle(90, 32, 8);
  } else {
    u8g2.drawCircle(90, 32, 4);
  }
  
  // Centered control instruction
  u8g2.drawBox(0, 52, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_6x10_tr);
  String instruction = "PRESS CENTER TO TOGGLE";
  int instrX = (128 - instruction.length() * 6) / 2;
  u8g2.drawStr(instrX, 60, instruction.c_str());
  u8g2.setColorIndex(1);
  
  u8g2.sendBuffer();
}

void updateLDRView() {
  String ldrStatus = readLDRStatus();
  uint8_t ldrValue = readLDRValue();
  uint8_t ledCount = calculateLEDProgress(ldrValue);
  
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(22, 9, "LIGHT SENSOR");
  u8g2.setColorIndex(1);
  
  // Main display - centered
  u8g2.drawRFrame(15, 14, 98, 32, 4);
  
  // Light reading - centered and prominent
  u8g2.setFont(u8g2_font_ncenB14_tr);
  String readingText = String(ldrValue);
  int readingX = 19 + (90 - readingText.length() * 14) / 2;
  u8g2.drawStr(readingX, 28, readingText.c_str());
  
  // Light status - centered
  u8g2.setFont(u8g2_font_6x10_tr);
  String statusText = "Status: " + ldrStatus;
  int statusX = 19 + (90 - statusText.length() * 6) / 2;
  u8g2.drawStr(statusX, 38, statusText.c_str());
  
  // Enhanced light level bar
  u8g2.drawFrame(15, 50, 98, 8);
  int barWidth = map(ldrValue, 0, 255, 0, 96);
  u8g2.drawBox(16, 51, barWidth, 6);
  
  // LED Progress Bar visualization on OLED
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(15, 63, "LEDs:");
  for (int i = 0; i < 12; i++) {
    int ledX = 40 + (i * 7);
    if (i < ledCount) {
      u8g2.drawBox(ledX, 59, 5, 4); // Filled box for lit LEDs
    } else {
      u8g2.drawFrame(ledX, 59, 5, 4); // Empty frame for unlit LEDs
    }
  }
  
  // Sun/moon animation based on light level
  if (ldrValue > 128) {
    // Sun animation
    u8g2.drawCircle(100, 20, 5);
    for (int i = 0; i < 8; i++) {
      int x = 100 + 8 * cos(i * PI / 4);
      int y = 20 + 8 * sin(i * PI / 4);
      u8g2.drawPixel(x, y);
    }
  } else {
    // Moon animation
    u8g2.drawCircle(100, 20, 4);
    u8g2.drawDisc(102, 18, 3);
  }
  
  u8g2.sendBuffer();
}

void updateObstacleView() {
  String obstacleStatus = readObstacleStatus();
  
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(8, 9, "OBSTACLE SENSOR");
  u8g2.setColorIndex(1);
  
  if (obstacleStatus == "Detected") {
    // Obstacle detected with radar-like animation
    if ((millis() / 250) % 2) {
      u8g2.drawRBox(20, 16, 88, 28, 4);
      u8g2.setColorIndex(0);
      
      u8g2.setFont(u8g2_font_ncenB10_tr);
      String obstacleText = "OBSTACLE";
      String alertText = "DETECTED!";
      
      // Center align obstacle text
      int obstacleX = 20 + (88 - obstacleText.length() * 10) / 2;
      int alertX = 20 + (88 - alertText.length() * 10) / 2;
      
      u8g2.drawStr(obstacleX, 25, obstacleText.c_str());
      u8g2.drawStr(alertX, 38, alertText.c_str());
      
      u8g2.setColorIndex(1);
    }
    
    // Animated radar sweep
    int sweepAngle = (millis() / 50) % 360;
    for (int r = 5; r < 15; r += 3) {
      u8g2.drawCircle(64, 30, r);
    }
    
    String pathText = "Path: BLOCKED";
    int pathX = (128 - pathText.length() * 6) / 2;
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(pathX, 55, pathText.c_str());
    
  } else {
    // No obstacle - centered display
    u8g2.drawRFrame(25, 16, 78, 28, 4);
    
    u8g2.setFont(u8g2_font_6x10_tr);
    String clearText = "PATH";
    String freeText = "CLEAR";
    
    // Center align text
    int clearX = 25 + (78 - clearText.length() * 6) / 2;
    int freeX = 25 + (78 - freeText.length() * 6) / 2;
    
    u8g2.drawStr(clearX, 25, clearText.c_str());
    u8g2.drawStr(freeX, 35, freeText.c_str());
    
    String pathClearText = "Path: CLEAR";
    int pathClearX = (128 - pathClearText.length() * 6) / 2;
    u8g2.drawStr(pathClearX, 55, pathClearText.c_str());
  }
  
  u8g2.sendBuffer();
}

void updateSoilMoistureView() {
  String soilStatus = readSoilMoistureStatus();
  uint8_t soilValue = readSoilMoistureValue();
  
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(15, 9, "SOIL MOISTURE");
  u8g2.setColorIndex(1);
  
  // Main display - centered
  u8g2.drawRFrame(15, 14, 98, 32, 4);
  
  // Soil moisture reading - centered and prominent
  u8g2.setFont(u8g2_font_ncenB14_tr);
  String readingText = String(soilValue);
  int readingX = 19 + (90 - readingText.length() * 14) / 2;
  u8g2.drawStr(readingX, 28, readingText.c_str());
  
  // Soil status - centered
  u8g2.setFont(u8g2_font_6x10_tr);
  String statusText = "Status: " + soilStatus;
  int statusX = 19 + (90 - statusText.length() * 6) / 2;
  u8g2.drawStr(statusX, 38, statusText.c_str());
  
  // Enhanced moisture level bar
  u8g2.drawFrame(15, 50, 98, 8);
  int barWidth = map(soilValue, 0, 255, 0, 96);
  u8g2.drawBox(16, 51, barWidth, 6);
  
  // Water drop animation based on moisture level
  if (soilValue > 100) {
    for (int i = 0; i < 3; i++) {
      int dropY = 20 + (millis() / 200 + i * 3) % 8;
      u8g2.drawCircle(100 + i * 4, dropY, 1);
    }
  }
  
  // Centered reading label
  u8g2.setFont(u8g2_font_micro_tr);
  String readingLabel = "Reading: " + String(soilValue);
  int labelX = (128 - readingLabel.length() * 4) / 2;
  u8g2.drawStr(labelX, 63, readingLabel.c_str());
  
  u8g2.sendBuffer();
}

/*************************************************
 *        IoT Mode Dashboard
 *************************************************/
void updateIoTModeScreen() {
  u8g2.clearBuffer();
  
  // Header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(25, 10, "IoT DASHBOARD");
  u8g2.setColorIndex(1);
  
  // Info box
  u8g2.drawRFrame(5, 16, 118, 36, 3);
  
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(10, 25, "SSID: ");
  u8g2.drawStr(40, 25, AP_SSID);
  
  u8g2.drawStr(10, 33, "Pass: ");
  u8g2.drawStr(40, 33, AP_PASSWORD);
  
  u8g2.drawStr(10, 41, "IP: ");
  IPAddress IP = WiFi.softAPIP();
  u8g2.setCursor(30, 41);
  u8g2.print(IP);
  
  u8g2.drawStr(10, 49, "Connected: ");
  int clients = WiFi.softAPgetStationNum();
  u8g2.setCursor(70, 49);
  u8g2.print(clients);
  u8g2.print(" device");
  if (clients != 1) u8g2.print("s");
  
  // Connection status indicator
  if (clients > 0) {
    u8g2.drawDisc(100, 25, 3);
  }
  
  // Exit instruction
  u8g2.setFont(u8g2_font_micro_tr);
  u8g2.drawStr(10, 63, "LEFT: EXIT");
  
  u8g2.sendBuffer();
}

/*************************************************
 *            Sensor Reading Functions
 *************************************************/
String getRainfallStatus() {
  Wire.beginTransmission(RAINFALL_SENSOR_ADDRESS);
  Wire.write(RAINFALL_COMMAND);
  if (Wire.endTransmission() != 0) {
    return "Error";
  }
  Wire.requestFrom(RAINFALL_SENSOR_ADDRESS, 1);
  if (Wire.available() == 1) {
    uint8_t status = Wire.read();
    return (status == 0) ? "Wet" : "Dry";
  }
  return "Error";
}

String readLDRStatus() {
  uint8_t value = readLDRValue();
  Serial.print("LDR Raw Value: ");
  Serial.println(value);
  
  if (value < 80) return "Dark";
  else if (value < 160) return "Dim";
  else return "Bright";
}

uint8_t readLDRValue() {
  // Direct I2C read without command - following reference code
  Wire.requestFrom(LDR_SENSOR_ADDRESS, 1);
  if (Wire.available()) {
    uint8_t reading = Wire.read();
    Serial.print("LDR Reading: ");
    Serial.println(reading);
    return reading;
  }
  
  Serial.println("LDR: No data available");
  return 128;  // Default value if no reading
}

String readObstacleStatus() {
  Wire.beginTransmission(OBSTACLE_SENSOR_ADDRESS);
  if (Wire.endTransmission() != 0) {
    return "Error";
  }
  Wire.requestFrom(OBSTACLE_SENSOR_ADDRESS, 1);
  if (Wire.available() == 1) {
    uint8_t status = Wire.read();
    return (status == 1) ? "Detected" : "Clear";
  }
  return "Error";
}

String readSoilMoistureStatus() {
  uint8_t value = readSoilMoistureValue();
  Serial.print("Soil Moisture Raw Value: ");
  Serial.println(value);
  
  // Following reference code logic
  if (value < 100) return "Dry";
  else return "Wet";
}

uint8_t readSoilMoistureValue() {
  // Direct I2C read without command - following reference code
  Wire.requestFrom(SOIL_MOISTURE_ADDRESS, 1);
  if (Wire.available()) {
    uint8_t reading = Wire.read();
    Serial.print("Soil Moisture Reading: ");
    Serial.println(reading);
    return reading;
  }
  
  Serial.println("Soil Moisture: No data available");
  return 50;  // Default value if no reading
}

/*************************************************
 *        Control Functions
 *************************************************/
void controlFan(bool state) {
  Wire.beginTransmission(FAN_ADDRESS);
  Wire.write(state ? 1 : 0); 
  Wire.endTransmission();
}

void controlPump(bool state) {
  Wire.beginTransmission(PUMP_ADDRESS);
  Wire.write(state ? 1 : 0); 
  Wire.endTransmission();
}

/*************************************************
 *          Audio Functions
 *************************************************/
void configureBuzzer() {
  pinMode(BUZZER_PIN, OUTPUT); 
  digitalWrite(BUZZER_PIN, LOW);
}

void playTone(int frequency) {
  tone(BUZZER_PIN, frequency, 500);
}

void stopTone() {
  noTone(BUZZER_PIN);
}

/*************************************************
 *        WiFi Functions
 *************************************************/
void setupWiFiAP() {
  WiFi.softAP(AP_SSID, AP_PASSWORD);
  IPAddress IP = WiFi.softAPIP();
  Serial.print("AP IP address: ");
  Serial.println(IP);
}

void stopWiFiAP() {
  WiFi.softAPdisconnect(true);
  WiFi.mode(WIFI_OFF);
}

/*************************************************
 *        LED Control Functions
 *************************************************/
void setupLEDs() {
  FastLED.addLeds<LED_TYPE, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(100); // Set brightness (0-255)
  
  // Initialize all LEDs to off
  fill_solid(leds, NUM_LEDS, CRGB::Black);
  FastLED.show();
  
  Serial.println("WS2812B LEDs initialized on GPIO 27");
}

void updateLEDs() {
  if (millis() - lastLEDUpdate < LED_UPDATE_INTERVAL) {
    return; // Don't update too frequently
  }
  lastLEDUpdate = millis();
  
  uint8_t ldrValue = readLDRValue();
  uint8_t progress = calculateLEDProgress(ldrValue);
  
  // Create rainbow progress bar based on LDR value
  rainbowProgressBar(progress);
  
  // Increment hue for rainbow cycling
  gHue++;
  
  FastLED.show();
}

uint8_t calculateLEDProgress(uint8_t ldrValue) {
  // Invert LDR logic: darker = more LEDs lit
  // LDR value: 0-255, where lower values = darker
  uint8_t inverted = 255 - ldrValue;
  
  // Map to number of LEDs (0-12)
  uint8_t numLEDs = map(inverted, 0, 255, 1, NUM_LEDS);
  
  Serial.print("LDR: ");
  Serial.print(ldrValue);
  Serial.print(" -> LEDs: ");
  Serial.println(numLEDs);
  
  return numLEDs;
}

void rainbowProgressBar(uint8_t numLEDs) {
  // Clear all LEDs first
  fill_solid(leds, NUM_LEDS, CRGB::Black);
  
  // Light up the specified number of LEDs with rainbow colors
  for (int i = 0; i < numLEDs && i < NUM_LEDS; i++) {
    // Create rainbow effect across the lit LEDs
    uint8_t hue = gHue + (i * 255 / NUM_LEDS);
    leds[i] = CHSV(hue, 255, 255);
  }
  
  // Add a breathing effect to the last lit LED
  if (numLEDs > 0 && numLEDs <= NUM_LEDS) {
    uint8_t brightness = beatsin8(60, 100, 255); // Breathing effect
    leds[numLEDs - 1] = CHSV(gHue + (numLEDs - 1) * 255 / NUM_LEDS, 255, brightness);
  }
}

void rainbowCycle() {
  // Full rainbow cycle across all LEDs
  for (int i = 0; i < NUM_LEDS; i++) {
    leds[i] = CHSV(gHue + (i * 255 / NUM_LEDS), 255, 255);
  }
}

/*************************************************
 *        Enhanced Music Mode with Better Piano Animation
 *************************************************/
void updateMusicModeView() {
  u8g2.clearBuffer();
  
  // Centered header
  u8g2.drawBox(0, 0, 128, 12);
  u8g2.setColorIndex(0);
  u8g2.setFont(u8g2_font_7x13B_tr);
  u8g2.drawStr(20, 9, "TOUCH PIANO");
  u8g2.setColorIndex(1);
  
  touch1 = touchRead(TOUCH_PIN1);
  touch2 = touchRead(TOUCH_PIN2);
  touch3 = touchRead(TOUCH_PIN3);
  touch4 = touchRead(TOUCH_PIN4);
  
  const char* notes[] = {"A", "B", "C", "D"};
  const int frequencies[] = {262, 294, 330, 349};
  
  bool anyPressed = false;
  
  // Centered piano keys
  int startX = (128 - (4 * 26 - 2)) / 2;
  
  for (int i = 0; i < 4; i++) {
    bool pressed = false;
    switch (i) {
      case 0: pressed = (touch1 < threshold); break;
      case 1: pressed = (touch2 < threshold); break;
      case 2: pressed = (touch3 < threshold); break;
      case 3: pressed = (touch4 < threshold); break;
    }
    
    int keyX = startX + i * 26;
    int keyY = 20;
    int keyW = 24;
    int keyH = 28;
    
    if (pressed) {
      // Pressed key animation
      u8g2.drawRBox(keyX, keyY, keyW, keyH, 3);
      u8g2.setColorIndex(0);
      u8g2.setFont(u8g2_font_ncenB14_tr);
      u8g2.drawStr(keyX + 8, keyY + 18, notes[i]);
      u8g2.setColorIndex(1);
      
      // Musical note animation floating up
      for (int j = 0; j < 3; j++) {
        int noteY = 15 - (millis() / 100 + j * 5) % 10;
        if (noteY > 5) {
          u8g2.drawPixel(keyX + 12 + j * 2, noteY);
          u8g2.drawPixel(keyX + 12 + j * 2 + 1, noteY);
        }
      }
      
      playTone(frequencies[i]);
      anyPressed = true;
    } else {
      // Normal key
      u8g2.drawRFrame(keyX, keyY, keyW, keyH, 3);
      u8g2.setFont(u8g2_font_ncenB10_tr);
      u8g2.drawStr(keyX + 9, keyY + 16, notes[i]);
    }
  }
  
  if (!anyPressed) {
    stopTone();
  }
  
  // Centered exit instruction
  u8g2.setFont(u8g2_font_micro_tr);
  u8g2.drawStr(75, 63, "RIGHT: EXIT");
  
  u8g2.sendBuffer();
}
